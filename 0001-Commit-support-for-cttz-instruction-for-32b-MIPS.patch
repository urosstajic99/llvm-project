From 07f29b90770665a9c27769134f8c28645a7be9ea Mon Sep 17 00:00:00 2001
From: Uros Stajic <uros.stajic@syrmia.com>
Date: Tue, 16 Aug 2022 09:09:12 +0200
Subject: [PATCH] Commit - support for cttz instruction for 32b MIPS

---
 .../AggressiveInstCombine.cpp                 | 97 +++++++++++--------
 llvm/test/Transforms/tests-for-mips32.ll      |  2 +-
 2 files changed, 59 insertions(+), 40 deletions(-)

diff --git a/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp b/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
index 36925864ad4e..b4c66eb7586f 100644
--- a/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
+++ b/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
@@ -334,7 +334,7 @@ static bool tryToRecognizePopCount(Instruction &I) {
   Value *MulOp0;
   // Matching "(i * 0x01010101...) >> 24".
   if ((match(Op0, m_Mul(m_Value(MulOp0), m_SpecificInt(Mask01)))) &&
-       match(Op1, m_SpecificInt(MaskShift))) {
+      match(Op1, m_SpecificInt(MaskShift))) {
     Value *ShiftOp0;
     // Matching "((i + (i >> 4)) & 0x0F0F0F0F...)".
     if (match(MulOp0, m_And(m_c_Add(m_LShr(m_Value(ShiftOp0), m_SpecificInt(4)),
@@ -439,83 +439,102 @@ static bool isCTTZTable(const ConstantDataArray &Table, uint64_t Mul,
 static bool tryToRecognizeTableBasedCttz(Instruction &I) {
 
   LoadInst *LI = dyn_cast<LoadInst>(&I);
-  if (!LI) return false;
+  if (!LI)
+    return false;
 
   // TODO: Support opaque pointers.
   Type *PtrTy = LI->getPointerOperand()->getType();
-  if (PtrTy->isOpaquePointerTy()) return false;
+  if (PtrTy->isOpaquePointerTy())
+    return false;
 
   Type *ElType = LI->getPointerOperandType()->getNonOpaquePointerElementType();
-  if (!ElType->isIntegerTy()) return false;
+  if (!ElType->isIntegerTy())
+    return false;
 
   GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(LI->getPointerOperand());
-  if (!GEP || !GEP->isInBounds() || GEP->getNumIndices() != 2) return false;
+  if (!GEP || !GEP->isInBounds() || GEP->getNumIndices() != 2)
+    return false;
 
   // TODO: Support opaque pointers.
   Type *PointeeTy = GEP->getPointerOperand()->getType();
-  if (PointeeTy->isOpaquePointerTy()) return false;
+  if (PointeeTy->isOpaquePointerTy())
+    return false;
 
   Type *GEPPointeeType =
       GEP->getPointerOperandType()->getNonOpaquePointerElementType();
-  if (!GEPPointeeType->isArrayTy()) return false;
+  if (!GEPPointeeType->isArrayTy())
+    return false;
 
   uint64_t ArraySize = GEPPointeeType->getArrayNumElements();
-  if (ArraySize != 32 && ArraySize != 64) return false;
+  if (ArraySize != 32 && ArraySize != 64)
+    return false;
 
   User *GEPUser = dyn_cast<User>(GEP->getPointerOperand());
-  if (!GEPUser) return false;
+  if (!GEPUser)
+    return false;
 
   ConstantDataArray *ConstData =
       dyn_cast<ConstantDataArray>(GEPUser->getOperand(0));
-  if (!ConstData) return false;
+  if (!ConstData)
+    return false;
 
   Value *Idx1 = GEP->idx_begin()->get();
   Constant *Zero = dyn_cast<Constant>(Idx1);
-  if (!Zero || !Zero->isZeroValue()) return false;
+  if (!Zero || !Zero->isZeroValue())
+    return false;
 
   Value *Idx2 = std::next(GEP->idx_begin())->get();
-  
+
   bool ConstIsWide = !match(Idx2, m_ZExt(m_Value()));
-  if(match(Idx2, m_LShr(m_Value(), m_Value())) && Idx2->getType()->isIntegerTy(32)) ConstIsWide=false;
-  
+  if (match(Idx2, m_LShr(m_Value(), m_Value())) &&
+      Idx2->getType()->isIntegerTy(32))
+    ConstIsWide = false;
+
   Value *X1;
   uint64_t MulConst, ShiftConst;
-  
-  if (match(Idx2, m_ZExt(m_Value())) && 
-  		!match(Idx2, m_ZExtOrSelf(m_LShr( 
-  			 m_ZExtOrSelf(m_Mul(m_c_And(m_Neg(m_Value(X1)), m_Deferred(X1)), 
-  		 				m_ConstantInt(MulConst))),
-  		 	 m_ConstantInt(ShiftConst)))))            
+
+  if (match(Idx2, m_ZExt(m_Value())) &&
+      !match(Idx2,
+             m_ZExtOrSelf(m_LShr(
+                 m_ZExtOrSelf(m_Mul(m_c_And(m_Neg(m_Value(X1)), m_Deferred(X1)),
+                                    m_ConstantInt(MulConst))),
+                 m_ConstantInt(ShiftConst)))))
     return false;
-  
+
   if (match(Idx2, m_LShr(m_Value(), m_Value())) &&
-  		 !match(Idx2, m_LShr(m_Mul(m_c_And(m_Neg(m_Value(X1)), m_Deferred(X1)),
-                                    		m_ConstantInt(MulConst)),
+      !match(Idx2, m_LShr(m_Mul(m_c_And(m_Neg(m_Value(X1)), m_Deferred(X1)),
+                                m_ConstantInt(MulConst)),
                           m_ConstantInt(ShiftConst))))
     return false;
-  
-  if (match(Idx2, m_Trunc(m_Value())) && 
-  		!match(Idx2, m_Trunc(m_LShr(m_Mul(m_c_And(m_Neg(m_Value(X1)), m_Deferred(X1)),
-  						m_ConstantInt(MulConst)), 
-  			m_ConstantInt(ShiftConst)))) && !match(Idx2, m_Trunc(m_LShr(m_Mul(m_ZExt(m_c_And(m_Neg(m_Value(X1)), m_Deferred(X1))),
-  						m_ConstantInt(MulConst)), 
-  			m_ConstantInt(ShiftConst)))))
-      return false;
-      
+
+  if (match(Idx2, m_Trunc(m_Value())) &&
+      !match(Idx2,
+             m_Trunc(m_LShr(m_Mul(m_c_And(m_Neg(m_Value(X1)), m_Deferred(X1)),
+                                  m_ConstantInt(MulConst)),
+                            m_ConstantInt(ShiftConst)))) &&
+      !match(Idx2, m_Trunc(m_LShr(m_Mul(m_ZExt(m_c_And(m_Neg(m_Value(X1)),
+                                                       m_Deferred(X1))),
+                                        m_ConstantInt(MulConst)),
+                                  m_ConstantInt(ShiftConst)))))
+    return false;
+
   unsigned InputBits = ConstIsWide ? 64 : 32;
 
   // Shift should extract top 5..7 bits.
-  if (ShiftConst < InputBits - 7 || ShiftConst > InputBits - 5) return false;
+  if (ShiftConst < InputBits - 7 || ShiftConst > InputBits - 5)
+    return false;
 
   Type *XType = X1->getType();
 
-  if (!XType->isIntegerTy(InputBits) && 
-  	!match(Idx2, m_Trunc(m_LShr(m_Mul(m_ZExt(m_c_And(
-  		m_Neg(m_Value(X1)), m_Deferred(X1))), m_ConstantInt(MulConst)),
-  			 m_ConstantInt(ShiftConst))))) return false;
+  if (!XType->isIntegerTy(InputBits) &&
+      !match(Idx2, m_Trunc(m_LShr(m_Mul(m_ZExt(m_c_And(m_Neg(m_Value(X1)),
+                                                       m_Deferred(X1))),
+                                        m_ConstantInt(MulConst)),
+                                  m_ConstantInt(ShiftConst)))))
+    return false;
 
-  if (!isCTTZTable(*ConstData, MulConst, ShiftConst, InputBits)) return false;
-  
+  if (!isCTTZTable(*ConstData, MulConst, ShiftConst, InputBits))
+    return false;
 
   auto ZeroTableElem = ConstData->getElementAsInteger(0);
   bool DefinedForZero = ZeroTableElem == InputBits;
diff --git a/llvm/test/Transforms/tests-for-mips32.ll b/llvm/test/Transforms/tests-for-mips32.ll
index 912eb52caaa1..b89f32b0cc41 100644
--- a/llvm/test/Transforms/tests-for-mips32.ll
+++ b/llvm/test/Transforms/tests-for-mips32.ll
@@ -242,7 +242,7 @@ entry:
 define dso_local i32 @ctz7(i32 noundef signext %x) local_unnamed_addr #0 {
 ; CHECK-LABEL: @ctz7(
 ; CHECK-NEXT:  entry:
-; CHECK-NEXT:    [[TMP0:%.*]] = call i32 @llvm.cttz.i32(i32 [[X:%.*]], i1 true)
+; CHECK-NEXT:    [[TMP0:%.*]] = call i32 @llvm.cttz.i32(i32 [[X:%.]], i1 true)
 ; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i32 [[X]], 0
 ; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 0, i32 [[TMP0]]
 ; CHECK-NEXT:    [[TMP3:%.*]] = trunc i32 [[TMP2]] to i8
-- 
2.34.1

